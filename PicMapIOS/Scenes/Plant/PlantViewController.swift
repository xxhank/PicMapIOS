//
//  PlantViewController.swift
//  PicMapIOS
//
//  Created by wangchaojs02 on 16/1/31.
//  Copyright (c) 2016年 wangchaojs02. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit
import MapKit
import SnapKit
import CoreLocation
import XCGLogger
import PKHUD

protocol PlantViewControllerInput
{
    func displayLocationInformation(viewModel: ViewModel<LocationViewModel, NSError>)
}

protocol PlantViewControllerOutput
{
    func fetchLocationInformation(request: Plant_FormatLocation_Requset)
}

class PlantViewController: UIViewController, PlantViewControllerInput
{
    var output: PlantViewControllerOutput!
    var router: PlantRouter!

    // MARK: - Outlet

    @IBOutlet weak var mapView: MKMapView!
    @IBOutlet weak var sightNameLabel: UILabel!
    @IBOutlet weak var cityNameLabel: UILabel!
    @IBOutlet weak var sightLocationLabel: UILabel!

    // MARK: - Action
    @IBAction func centerMe() {
        self.centerMapOnLocation(initialLocation, regionRadius: self.regionRadius)
    }

    // MARK: - Location
    var locationManager = CLLocationManager()
    let regionRadius: CLLocationDistance = 1000 * 1000 // 默认1000
    var initialLocation = CLLocation(latitude: 39.9, longitude: 116.3)

    // MARK: Object lifecycle

    override func awakeFromNib()
    {
        super.awakeFromNib()
        PlantConfigurator.sharedInstance.configure(self)
    }

    // MARK: View lifecycle

    override func viewDidLoad()
    {
        super.viewDidLoad()

        setupMapView()

        doSomethingOnLoad()
    }

    // MARK: Event handling

    func doSomethingOnLoad()
    {
        // NOTE: Ask the Interactor to do some work
        // let request = PlantRequest()
    }

    // MARK: Display logic

    func displayLocationInformation(viewModel: ViewModel<LocationViewModel, NSError>) {
        switch viewModel {
        case .Result(let result):
            self.cityNameLabel.text = result.city;
            self.sightNameLabel.text = result.location;
            self.sightLocationLabel.text = result.street;
        case .Error(let error):
            PKHUD.sharedHUD.contentView = PKHUDTextView(text: error.localizedDescription)
            PKHUD.sharedHUD.show()
            PKHUD.sharedHUD.hide(afterDelay: 2.0)
        }
    }
}

// MARK: - Location

extension PlantViewController: MKMapViewDelegate, CLLocationManagerDelegate {

    // MARK: - Help Method
    func setupMapView()
    {
        checkLocationAuthorizationStatus()

        self.locationManager.delegate = self;
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        self.locationManager.requestAlwaysAuthorization()
        self.locationManager.startUpdatingLocation()
        self.locationManager.distanceFilter = CLLocationDistance(1000)

        self.mapView.delegate = self

        self.centerMapOnLocation(initialLocation, regionRadius: self.regionRadius)
    }

    func checkLocationAuthorizationStatus() {
        if CLLocationManager.authorizationStatus() == .AuthorizedWhenInUse {
            mapView.showsUserLocation = true;
        } else {
            locationManager.requestWhenInUseAuthorization() ;
            mapView.showsUserLocation = true;
        }
    }

    func centerMapOnLocation(location: CLLocation, regionRadius : CLLocationDistance)
    {
        let corrdinateRegion = MKCoordinateRegionMakeWithDistance(location.coordinate, regionRadius, regionRadius)
        mapView.setRegion(corrdinateRegion, animated: true)
    }

    // MARK: - CLLocationManagerDelegate
    func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        let currentLocation: CLLocation = locations.last!;
        self.mapView.region = MKCoordinateRegionMakeWithDistance(currentLocation.coordinate, regionRadius, regionRadius) ;
        self.locationManager.stopUpdatingLocation() ;
    }

    func locationManager(manager: CLLocationManager, didFailWithError error: NSError) {
    }

    // MARK: - MKMapViewDelegate
    func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -> MKAnnotationView? {
//        if let annotation = annotation as? AnnotationGroup {
//            let pinView = ArtWorkAnnotationView.annotationView(mapView, annotation: annotation)
//            pinView.pinSelected = false
//            return pinView
//        }
//        else{
//            return nil
//        }
        return nil
    }

    func mapView(mapView: MKMapView, didSelectAnnotationView view: MKAnnotationView) {
        mapView.deselectAnnotation(view.annotation, animated: true)
//        if view .isKindOfClass(ArtWorkAnnotationView ) {
//            let pinView = view as! ArtWorkAnnotationView
//            //点击不同的大头针还原之前的大头针
//            if self.pinView != nil && self.pinView != pinView {
//                self.pinView.selected = false
//                self.pinView = pinView
//
//            } else {
//                self.pinView = pinView
//            }
//
//
//
//            pinView.selected = false
//            pinView.pinSelected = !pinView.pinSelected
//            if pinView.pinSelected == false {
//                UIView.animateWithDuration(0.5) { () -> Void in
//                    self.scrollView.transform = CGAffineTransformIdentity
//                }
//            }else
//            {
//                UIView.animateWithDuration(0.5) { () -> Void in
//                    self.scrollView.transform = CGAffineTransformMakeTranslation(0, -self.scrollViewHeight)
//                }
//            }
//
//        }
    }
    func mapView(mapView: MKMapView, regionWillChangeAnimated animated: Bool) {
//        if self.scrollView != nil {
//            UIView.animateWithDuration(0.5) { () -> Void in
//                if self.pinView != nil {
//                    self.pinView.pinSelected = false
//                }
//
//                self.scrollView.transform = CGAffineTransformIdentity
//            }
//        }
    }
    func mapView(mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
        guard let centerLocation = mapView.userLocation.location else { return } // CLLocation(latitude: mapView.centerCoordinate.latitude
        // , longitude: mapView.centerCoordinate.longitude)
        output.fetchLocationInformation(Plant_FormatLocation_Requset(location: centerLocation))
    }

    func mapView(mapView: MKMapView, didUpdateUserLocation userLocation: MKUserLocation) {
        self.initialLocation = userLocation.location!
        /**
         * 根据地理位置,解析出城市名称
         */
        output.fetchLocationInformation(Plant_FormatLocation_Requset(location: userLocation.location!))
    }
}
